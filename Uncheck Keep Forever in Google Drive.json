{"files":[{"id":"b6a1b41f-83ba-4209-9c54-805136395a10","name":"appsscript","type":"json","source":"{\n  \"timeZone\": \"Europe/Bucharest\",\n  \"exceptionLogging\": \"STACKDRIVER\",\n  \"runtimeVersion\": \"V8\",\n  \"dependencies\": {\n    \"enabledAdvancedServices\": [\n      {\n        \"userSymbol\": \"Drive\",\n        \"version\": \"v2\",\n        \"serviceId\": \"drive\"\n      }\n    ]\n  }\n}"},{"id":"2149f1fb-9aa1-4577-b5f7-93572dab6f81","name":"Code","type":"server_js","source":"/**\n * This script iterates through all Microsoft Word documents and PDFs in a user\u0027s\n * Google Drive and unchecks the \"Keep forever\" setting for file revisions (versions).\n *\n * This version is designed for large drives and can be run multiple times. It\n * automatically saves its progress and resumes where it left off. If it times out,\n * simply run it again.\n *\n * IMPORTANT: You must enable the advanced \"Drive API\" service for this script to work.\n */\n\nconst SCRIPT_PROPERTY_KEY \u003d \u0027DRIVE_CONTINUATION_TOKEN\u0027;\n\n/**\n * Main function to find and update files. Resumes automatically.\n */\nfunction uncheckKeepForever() {\n  const startTime \u003d new Date().getTime();\n  const properties \u003d PropertiesService.getUserProperties();\n  let pageToken \u003d properties.getProperty(SCRIPT_PROPERTY_KEY);\n\n  if (!pageToken) {\n    Logger.log(\u0027Starting a new scan from the beginning...\u0027);\n  } else {\n    Logger.log(`Resuming scan from a saved position: ${pageToken}`);\n  }\n\n  // Construct a specific query to only find the file types we\u0027re interested in.\n  const query \u003d \"trashed \u003d false and (\" +\n    \"mimeType \u003d \u0027application/pdf\u0027 or \" +\n    \"mimeType \u003d \u0027application/vnd.openxmlformats-officedocument.wordprocessingml.document\u0027 or \" +\n    \"mimeType \u003d \u0027application/msword\u0027\" +\n  \")\";\n\n  let filesScanned \u003d 0;\n  let revisionsUpdated \u003d 0;\n\n  do {\n    // Check if the script is approaching the execution time limit (6 minutes).\n    // We\u0027ll stop at 5 minutes (300,000 ms) to be safe.\n    const currentTime \u003d new Date().getTime();\n    if (currentTime - startTime \u003e 300000) {\n      Logger.log(\u0027Approaching maximum execution time. Saving progress and stopping.\u0027);\n      Logger.log(\u0027Please run the script again to continue where it left off.\u0027);\n      // The pageToken is already saved after each successful API call, so we just need to exit.\n      return;\n    }\n\n    try {\n      // Step 1: Get a list of file IDs that match our query.\n      const fileList \u003d Drive.Files.list({\n        q: query,\n        maxResults: 100, // Smaller batch to account for extra revision API calls per file\n        pageToken: pageToken,\n        fields: \"items(id, title), nextPageToken\"\n      });\n\n      if (fileList \u0026\u0026 Array.isArray(fileList.items) \u0026\u0026 fileList.items.length \u003e 0) {\n        // Step 2: Process each file individually.\n        for (const file of fileList.items) {\n          filesScanned++;\n          try {\n            // Get the list of revisions for this file.\n            const revisions \u003d Drive.Revisions.list(file.id, {\n              fields: \"items(id, pinned)\"\n            }).items || [];\n\n            // Step 3: Update each pinned revision.\n            for (const revision of revisions) {\n              if (revision.pinned \u003d\u003d\u003d true) {\n                Drive.Revisions.update({ pinned: false }, file.id, revision.id);\n                Logger.log(`Updated revision ${revision.id} for file: \"${file.title}\" (ID: ${file.id})`);\n                revisionsUpdated++;\n              }\n            }\n          } catch (e) {\n            // This catches errors for single files so the whole script doesn\u0027t stop.\n            Logger.log(`Could not process revisions for file with ID: ${file.id}. Error: ${e.toString()}`);\n          }\n        }\n      }\n\n      // Set the token for the next page of results.\n      pageToken \u003d fileList ? fileList.nextPageToken : null;\n      \n      // Save the token for the next page in case of timeout.\n      if (pageToken) {\n        properties.setProperty(SCRIPT_PROPERTY_KEY, pageToken);\n      }\n\n    } catch (apiError) {\n      Logger.log(`A critical error occurred: ${apiError.toString()}. Stopping script.`);\n      pageToken \u003d null; // Stop the loop on a critical error.\n    }\n\n  } while (pageToken);\n\n  // If the loop completes, it means we\u0027re done. Clear the saved token.\n  properties.deleteProperty(SCRIPT_PROPERTY_KEY);\n  const summary \u003d `Script finished successfully! Scanned ${filesScanned} files and updated ${revisionsUpdated} revisions in this run. All files have been processed.`;\n  Logger.log(summary);\n\n  try {\n    SpreadsheetApp.getUi().alert(summary);\n  } catch (uiError) {\n    Logger.log(\u0027Could not display a UI alert.\u0027);\n  }\n}\n\n/**\n * Resets the script\u0027s saved progress.\n */\nfunction resetScriptState() {\n  const properties \u003d PropertiesService.getUserProperties();\n  properties.deleteProperty(SCRIPT_PROPERTY_KEY);\n  Logger.log(\u0027Script progress has been reset. The next run will start from the beginning.\u0027);\n  try {\n    SpreadsheetApp.getUi().alert(\u0027Script progress has been reset.\u0027);\n  } catch(e) { /* Ignore if not in a sheet */ }\n}\n\n/**\n * Adds a custom menu to the Google Sheet UI.\n */\nfunction onOpen() {\n  SpreadsheetApp.getUi()\n      .createMenu(\u0027Drive Tools\u0027)\n      .addItem(\u0027Uncheck \"Keep Forever\" (Run)\u0027, \u0027uncheckKeepForever\u0027)\n      .addSeparator()\n      .addItem(\u0027Reset Script\u0027, \u0027resetScriptState\u0027)\n      .addToUi();\n}"}]}